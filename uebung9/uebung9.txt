0.)
Chosen Ciphertext-Angriff
m0 = 000...0
m1 = 111...1
=> c= (IV, z) z...Chiffrat
c' = (IV, z xor 100...0)

Entweder m' = 100000... => b = 0
oder     m' = 011111... => b = 1

Pr[b'=1|b=1] = 1
Pr[b'=1|b=0] = 0
=> Vorteil = 1

Da nur xor verändern sich stellen nicht.
Wir senden beide Nachrichten an den Challender.
Wir ändern 1 bit bei output und lassen entschlüsseln.
Wir sehen anhand von stelle welche nachricht verschlüsselt wurde.


1.)
Ciphertext wird erst für 2. Plaintext verwendet.
Nachricht aus zwei Blöcken:
c0 = 0000 0000
c1 = 1111 1111


m0 = 0000 1111
m1 = 0000 0000

Da 2. sich zweiter Nachrichtenteil unterscheidet sehe ich im zweiten Block
welche Nachricht verwendet wurde

2.)
m0 = 000 m1 = 111
m0 = 000 m1 = 001

Ich schicke c1 & c2, wenn error, dann m1 (da c1&c2 nicht gleich), ansonten
m0, mit Vorteil 1

3.)
bei c2 wird IV verwendet
bei m wird IV mit c2 verwendet

Zweimal gleiche Nachricht m = 000 hinschicken
c_1_1 = Fk(IV_1)
c_2_1 = Fk(m) xor IV_1

c_1_2 = FK(IV_2)
c_2_2 = Fk(m) xor IV_2

c_2_1 xor c_2_2 = IV_1 xor IV_2 //m kürzt sich raus

Decrypt:
IV = Fk⁻¹(c_1_1)
m = Fk⁻¹(c_2_1 xor c_2_2 xor IV_1) = Fk⁻¹(IV_2)
Fk(m) = IV_2

4.)
E_k = ________
        xor
c   = ________
        ->
      ________ = p (mit 0x00 an letzter stelle)

Wir streichen letztes Byte weg.
Wir können durchtesten bis wir wieder 00 haben (Server approved)
und wissen somit was an letzter stelle gestanden ist.
-> Worst case: 256 Möglichkeiten testen


